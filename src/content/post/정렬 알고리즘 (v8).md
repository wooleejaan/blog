---
title: '정렬 알고리즘 (v8)'
description: 'v8 엔진에서 사용하는 정렬 알고리즘'
pubDate: 'Apr 28 2024'
---

#### 동적 언어에서 정렬이 어려운 이유

JavaScript와 같은 동적 언어에서 비교 작업은 무거운 작업이 되기 쉽다.<br>
비교에 필요한 콜백 함수를 사용자가 임의로 작성할 수 있어, 일관성이 없기 때문이다.

```js
const array = [4, 2, 5, 3, 1]

function compare(a, b) {
  // Arbitrary code goes here, e.g. `array.push(1);`.
  return a - b
}

// A “typical” sort call.
array.sort(compare)
```

#### V8 엔진에서는

실제로 요소를 정렬할 때, 전처리 및 후처리 작업을 포함해 3단계를 거친다.

1. 실제 정렬을 하기 전, undefined이 아닌 요소들을 임시 list에 모아두고 정렬을 한다. (실제로 comparison function은 여기에서만 쓰인다)
2. undefined인 요소들을 별도로 처리한다. (undefined만 존재하므로 실제로 정렬을 수행하지 않고 length만 계산하면 된다)
3. 정렬이 완료되면 원본 배열이나 객체에 다시 값을 덮어 쓴다.

#### 사용했었고, 사용하고 있는 정렬 알고리즘

과거 Array.prototype.sort는 Quick Sort에 의존했다(현재는 Tim Sort).

- Quick Sort는 pivot 설정이 성능에 큰 영향을 미친다. (참조 지역성의 원리 때문이다)

Tim Sort는 Merge Sort를 변형한 형태이며, 보다 효율적이다.

- Merge Sort가 재귀적으로 동작한다면, Tim Sort는 반복적으로(iteratively) 동작한다. (minrun ~ merge ~ galloping ...)
- QuickSort에서 TimSort로의 전환 과정에서는, 병합 실행을 위해 임시 배열이 필요하다. 다만, 이 임시 배열은 V8의 새로운 공간에 빠르게 할당되고, 빠르게 폐기된다(수명이 짧다).

#### 비교 정렬 알고리즘에 관한 더 많은 이야기

다양한 정렬 알고리즘이 존재한다. 평균 시간 복잡도를 기준으로 한다면, Bubble Sort, Insertion Sort가 `O(n^2)`이고, Heap Sort/Merge Sort/Quick Sort가 `O(n long n)`에 해당한다.

시간복잡도는 참조 지역성 원리에 의존한다. (즉, 같은 `O(n long n)`이더라도 C 상수에 따라 성능이 달라진다. `C * n logn + α`)

- Heap Sort는 참조 지역성이 좋지 않은 정렬 알고리즘이다. 비교하는 인덱스의 범위가 넓기에, 캐시 메모리 입장에서 예측하기가 어렵다.
- Merge Sort는 인접한 구간을 비교하고 병합하므로 참조 지역성은 좋지만, 입력 배열 크기만큼 메모리를 추가적으로 사용한다.
- Quick Sort는 pivot을 주변으로 참조지역성이 대체로 좋다. 다만, pivot 선정에 따라 최악의 경우 `O(n^2)`까지 갈 수 있다.

#### 참고 자료

<a href="https://v8.dev/blog/array-sort#timsort" target="_blank">Getting things sorted in V8</a><br>
<a href="https://www.linkedin.com/pulse/javascript-v8-sorting-algorithm-behind-scene-arraysort-mazahar-shaikh/" target="_blank">JavaScript V8 : Sorting Algorithm behind the scene for Array.sort()</a><br>
<a href="https://d2.naver.com/helloworld/0315536" target="_blank">Tim sort에 대해 알아보자</a><br>
